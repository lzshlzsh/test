/*
 * perf_self_sample.c - example of how you can use overflow notifications
 *
 * Copyright (c) 2009 Google, Inc
 * Contributed by Stephane Eranian <eranian@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <sys/types.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <pthread.h>
#include "optimization.h"
#include "mem_manage.h"
#include "perf_util.h"
#include "perf_sample.h"

static volatile UINT32 overflow_count;
static perf_event_desc_t *fds;
static int num_events;

static pthread_mutex_t buflock = PTHREAD_MUTEX_INITIALIZER;

volatile UINT32 unprocessed_sample;

SMPLINDEX *SmplHashTable;
SAMPLE *aSmpl;
SMPLINDEX nSmpl;

PERF_READ_FORMAT *pEventBuffer;

pid_t gettid(void) {
	return (pid_t)syscall(__NR_gettid);
}

SMPLINDEX SmplNew() {
    ASSERT(nSmpl<MAXNSMPL, ("Sample array is overflow.\n"))
    return (nSmpl++);
}

int AnalyzeSamples() {
    UINT64 ip;
    UINT32 ihash, ismpl, ifuncinfo;
    int i, j;

    pthread_mutex_lock(&buflock);
    for(i=0; i<N_WAKEUP_EVENTS; i++) {
        if(pEventBuffer[i]._event_header.type != PERF_RECORD_SAMPLE) {
            OUTPUT(("unexpected sample type=%d, skipping.\n", pEventBuffer[i]._event_header.type));
            continue;
        }

        ip = pEventBuffer[i]._ip;
        ip = ip & 0x0fffffffc;
        ihash = (((ip >> 16) + (ip & 0xffff)) % N_SMPL_HASH_TABLE);
        ismpl = SmplHashTable[ihash];
        while(ismpl) {
            if(aSmpl[ismpl]._ip == ip)
                break;
            else
                ismpl = aSmpl[ismpl]._next;
        }
        if(ismpl)
            aSmpl[ismpl]._count ++;
        else {
            ismpl = SmplNew();
            aSmpl[ismpl]._ip = ip;
            aSmpl[ismpl]._count = 1;
            aSmpl[ismpl]._next = SmplHashTable[ihash];
            SmplHashTable[ihash] = ismpl;
        }
    }
    unprocessed_sample = 0;
    pthread_mutex_unlock(&buflock);

    if(overflow_count%10 == 0) {
        for(ismpl=1; ismpl<nSmpl; ismpl++) {
            for(j=0; j<aFile._func_index; j++) {
                if(aSmpl[ismpl]._ip>=aFile._p_func_info[j]._entry_addr && aSmpl[ismpl]._ip<aFile._p_func_info[j]._end_addr) {
                    aFile._p_func_info[j]._sample_count += aSmpl[ismpl]._count;
                    break;
                }
            }
            aFile._tot_sample_count += aSmpl[ismpl]._count;
        }

        return 1;
    }

    return 0;
}

static void
sigio_handler(int n, struct siginfo *info, void *uc) {
	struct perf_event_header ehdr;
	INT32 ret, id;
    size_t sz;
	
	/*
	 * positive si_code indicate kernel generated signal
	 * which is normal for SIGIO
	 */
    FATAL(info->si_code < 0, ("signal not generated by kernel\n"));

	/*
	 * SIGPOLL = SIGIO
	 * expect POLL_HUP instead of POLL_IN because we are
	 * in one-shot mode (IOC_REFRESH)
	 */
    ASSERT(info->si_code==POLL_HUP, ("signal not generated by SIGIO\n"));

	id = perf_fd2event(fds, num_events, info->si_fd);
    ASSERT(id!=-1, ("no event associated with fd=%d\n", info->si_fd));

    while(unprocessed_sample);
    pthread_mutex_lock(&buflock);
    ret = perf_read_buffer(fds[id].buf, fds[id].pgmsk, (void *)pEventBuffer, N_WAKEUP_EVENTS*sizeof(PERF_READ_FORMAT));
    unprocessed_sample = 1;
    pthread_mutex_unlock(&buflock);
    ASSERT(ret==0, ("read event buffer error.\n"));

    for(;;) {
        ret = perf_read_buffer(fds[id].buf, fds[id].pgmsk, &ehdr, sizeof(ehdr));
        if(ret)
            goto epilog;
        else {
            OUTPUT(("Did not correctly parse sample.\n", sz));
            perf_skip_buffer(fds[id].buf, ehdr.size - sizeof(ehdr));
        }
    }

epilog:
	/*
	 * increment our notification counter
	 */
	overflow_count++;
    if(overflow_count%10 == 0) {
        ret = ioctl(fds[0].fd, PERF_EVENT_IOC_DISABLE, 0);
	    ASSERT(ret!=-1, ("cannot disable pfmon.\n"));
        in_monitoring = 0;
        return;
    }
	/*
 	 * rearm the counter for one more shot
 	 */
	ret = ioctl(info->si_fd, PERF_EVENT_IOC_REFRESH, N_WAKEUP_EVENTS);
    ASSERT(ret!=-1, ("cannot refresh perf event\n"));
}

void pfmon_init() {
    struct sigaction act;
    struct f_owner_ex fown_ex;
    UINT64 *val;
    size_t sz;
	int ret, i;

    SmplHashTable = (SMPLINDEX *)MmAllocShMem(N_SMPL_HASH_TABLE*sizeof(SMPLINDEX));
    val = (UINT64 *)SmplHashTable;
    for(i=0; i<N_SMPL_HASH_TABLE/2; i++)
        val[i] = 0;

    aSmpl = (SAMPLE *)MmAllocShMem(MAXNSMPL*sizeof(SAMPLE));
    val = (UINT64 *)aSmpl;
    for(i=0; i<MAXNSMPL*3/2; i++)
        val[i] = 0;
    
    nSmpl = INVALID + 1;

    pEventBuffer = (PERF_READ_FORMAT *)MmAllocShMem((N_WAKEUP_EVENTS+1)*sizeof(PERF_READ_FORMAT));

	ret = pfm_initialize();
	ASSERT(ret==PFM_SUCCESS, ("Cannot initialize library: %s", pfm_strerror(ret)));

    /*
	 * Install the signal handler (SIGIO)
	 * need SA_SIGINFO because we need the fd
	 * in the signal handler
	 */
	memset(&act, 0, sizeof(act));
	act.sa_sigaction = sigio_handler;
	act.sa_flags = SA_SIGINFO;
	sigaction (SIGIO, &act, 0);

	/*
 	 * allocates fd for us
 	 */
	ret = perf_setup_list_events("UNHALTED_CORE_CYCLES", &fds, &num_events);
	FATAL(ret||(num_events==0), ("no event is specified!\n"));

	fds[0].fd = -1;
	for(i=0; i < num_events; i++) {
		fds[i].hw.disabled = !i;
        //fds[i].hw.inherit = 1;

        /*
		 * set notification threshold to be halfway through the buffer
		fds[i].hw.wakeup_watermark = (BUFFER_PAGES*PAGE_SIZE) / 2; 
		fds[i].hw.watermark = 1;
        */

		if (!i) {
            fds[i].hw.wakeup_events = N_WAKEUP_EVENTS;
			fds[i].hw.sample_type = PERF_SAMPLE_IP;
			fds[i].hw.sample_period = SMPL_PERIOD;

			/* read() returns event identification for signal handler */
            fds[i].hw.read_format = 0;
			/**if (num_events > 1)
				fds[i].hw.read_format |= PERF_FORMAT_GROUP|PERF_FORMAT_ID;*/
		} 

		fds[i].fd = perf_event_open(&fds[i].hw, gettid(), -1, fds[0].fd, 0);
		ASSERT(fds[i].fd!=-1, ("cannot attach event %s", fds[i].name));
	}

	sz = (3+2*num_events)*sizeof(UINT64);
	val = malloc(sz);
	/*
	 * On overflow, the non lead events are stored in the sample.
	 * However we need some key to figure the order in which they
	 * were laid out in the buffer. The file descriptor does not
	 * work for this. Instead, we extract a unique ID for each event.
	 * That id will be part of the sample for each event value.
	 * Therefore we will be able to match value to events
	 *
	 * PERF_FORMAT_ID: returns unique 64-bit identifier in addition
	 * to event value.
	 */
	ret = read(fds[0].fd, val, sz);
	ASSERT(ret!=-1, ("cannot read id %zu", sizeof(val)));

	/*
	 * we are using PERF_FORMAT_GROUP, therefore the structure
	 * of val is as follows:
	 *
	 *      { u64           nr;
	 *        { u64         time_enabled; } && PERF_FORMAT_ENABLED
	 *        { u64         time_running; } && PERF_FORMAT_RUNNING
	 *        { u64         value;                  
	 *          { u64       id;           } && PERF_FORMAT_ID
	 *        }             cntr[nr];               
	 * We are skipping the first 3 values (nr, time_enabled, time_running)
	 * and then for each event we get a pair of values.
	 */ 
	for(i=0; i < num_events; i++) {
		fds[i].id = val[2*i+1+3];
		//printf("%"PRIu64"  %s\n", fds[i].id, fds[i].name);
	}
	 
	/*
	 * setup asynchronous notification on the file descriptor
	 */
	ret = fcntl(fds[0].fd, F_SETFL, fcntl(fds[0].fd, F_GETFL, 0) | O_ASYNC);
	ASSERT(ret!=-1, ("fcntl cannot set ASYNC"));

	/*
	 * get ownership of the descriptor
	 */
	fown_ex.type = F_OWNER_TID;
	fown_ex.pid  = gettid();
	ret = fcntl(fds[0].fd, F_SETOWN_EX, (unsigned long)&fown_ex);
	ASSERT(ret!=-1, ("fcntl SETOWN failed"));

	/*
 	 * necessary if we want to get the file descriptor for
 	 * which the SIGIO is sent in siginfo->si_fd.
 	 * SA_SIGINFO in itself is not enough
 	 */
	ret = fcntl(fds[0].fd, F_SETSIG, SIGIO);
	ASSERT(ret!=-1, ("fcntl cannot setsig"));

	fds[0].buf = mmap(NULL, (BUFFER_PAGES+1)*PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fds[0].fd, 0);
	ASSERT(fds[0].buf!=MAP_FAILED, ("cannot mmap buffer"));
	
	fds[0].pgmsk = (BUFFER_PAGES * PAGE_SIZE) - 1;

	/*
	 * enable the group for one period
	 */
	ret = ioctl(fds[0].fd, PERF_EVENT_IOC_REFRESH , N_WAKEUP_EVENTS);
	ASSERT(ret!=-1, ("cannot refresh"));

    in_monitoring = 1;
    free(val);
}

void pfmon_fini() {
    int ret, i;
    
    ret = ioctl(fds[0].fd, PERF_EVENT_IOC_DISABLE, 0);
	ASSERT(ret!=-1, ("cannot disable pfmon.\n"));

    in_monitoring = 0;
	/*
	 * destroy our session
	 */
	for(i=0; i < num_events; i++)
		close(fds[i].fd);
    munmap(fds[0].buf, (BUFFER_PAGES+1)*PAGE_SIZE);

	free(fds);
}

void pfmon_start() {
    int i, ret;
    UINT64 *val;

    for(i=0; i<aFile._func_index; i++) {
        aFile._p_func_info[i]._sample_count = 0;
        aFile._p_func_info[i]._exec_count = 0;
    }
    aFile._tot_sample_count = 0;

    val = (UINT64 *)SmplHashTable;
    for(i=0; i<N_SMPL_HASH_TABLE/2; i++)
        val[i] = 0;

    val = (UINT64 *)aSmpl;
    for(i=0; i<MAXNSMPL*3/2; i++)
        val[i] = 0;

    nSmpl = INVALID + 1;
    
    ret = ioctl(fds[0].fd, PERF_EVENT_IOC_REFRESH, N_WAKEUP_EVENTS);
    ASSERT(ret!=-1, ("cannot refresh perf event\n"));
    in_monitoring = 1;
}

void pfmon_stop() {
    int ret;
    ret = ioctl(fds[0].fd, PERF_EVENT_IOC_DISABLE, 0);
	ASSERT(ret!=-1, ("cannot disable pfmon.\n"));
}

#ifdef _HELPER_THREAD
void MapSamplesToFun() {
    UINT32 ismpl;
    OUTLPINDEX iOutLp;
    BBINDEX ibb;

    for(ismpl=1; ismpl<nSmpl; ismpl++) {
        if(aSmpl[ismpl]._ip>=aFun[ifun]._entry_addr && aSmpl[ismpl]._ip<aFun[ifun]._entry_addr+aFun[ifun]._func_size) {
            aFun[ifun]._samples += aSmpl[ismpl]._count;
            ibb = aFun[ifun]._ibb_head;
            while(ibb) {
                if(aSmpl[ismpl]._ip>=aBb[ibb]._entry_addr && aSmpl[ismpl]._ip<=aBb[ibb]._end_addr) {
                    aBb[ibb]._samples += aSmpl[ismpl]._count;
                    iOutLp = 1;
                    while(iOutLp<nOutLp) {
                        if(ArrayExist(aOutLoop[iOutLp]._member, ibb)) {
                            aOutLoop[iOutLp]._samples += aSmpl[ismpl]._count;
                            break;
                        }

                        iOutLp += 1;
                    }
                    break;
                }
                ibb = aBb[ibb]._next;
            }
        }
    }
}
#endif


